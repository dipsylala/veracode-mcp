/*
Veracode Applications API Specification

Veracode Applications API Documentation  Use one of the following base URLs depending on the region for your account: * https://api.veracode.com/ - Veracode US Region (default) * https://api.veracode.eu/ - Veracode European Region * https://api.veracode.us/ - Veracode US Federal Region

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package applications

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// ApplicationInformationAPIAPIService ApplicationInformationAPIAPI service
type ApplicationInformationAPIAPIService service

type ApiCreateApplicationUsingPOSTRequest struct {
	ctx context.Context
	ApiService *ApplicationInformationAPIAPIService
	application *Application
}

// The application object to be created.
func (r ApiCreateApplicationUsingPOSTRequest) Application(application Application) ApiCreateApplicationUsingPOSTRequest {
	r.application = &application
	return r
}

func (r ApiCreateApplicationUsingPOSTRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.CreateApplicationUsingPOSTExecute(r)
}

/*
CreateApplicationUsingPOST createApplication

Creates a new application and links it to associated resources such as policies and sandboxes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateApplicationUsingPOSTRequest
*/
func (a *ApplicationInformationAPIAPIService) CreateApplicationUsingPOST(ctx context.Context) ApiCreateApplicationUsingPOSTRequest {
	return ApiCreateApplicationUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Application
func (a *ApplicationInformationAPIAPIService) CreateApplicationUsingPOSTExecute(r ApiCreateApplicationUsingPOSTRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationInformationAPIAPIService.CreateApplicationUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.application == nil {
		return localVarReturnValue, nil, reportError("application is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.application
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Application
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApplicationUsingDELETERequest struct {
	ctx context.Context
	ApiService *ApplicationInformationAPIAPIService
	applicationGuid string
}

func (r ApiDeleteApplicationUsingDELETERequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteApplicationUsingDELETEExecute(r)
}

/*
DeleteApplicationUsingDELETE deleteApplication

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationGuid The application GUID.
 @return ApiDeleteApplicationUsingDELETERequest
*/
func (a *ApplicationInformationAPIAPIService) DeleteApplicationUsingDELETE(ctx context.Context, applicationGuid string) ApiDeleteApplicationUsingDELETERequest {
	return ApiDeleteApplicationUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		applicationGuid: applicationGuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ApplicationInformationAPIAPIService) DeleteApplicationUsingDELETEExecute(r ApiDeleteApplicationUsingDELETERequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationInformationAPIAPIService.DeleteApplicationUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/applications/{applicationGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationGuid"+"}", url.PathEscape(parameterValueToString(r.applicationGuid, "applicationGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Application
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationUsingGETRequest struct {
	ctx context.Context
	ApiService *ApplicationInformationAPIAPIService
	applicationGuid string
}

func (r ApiGetApplicationUsingGETRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.GetApplicationUsingGETExecute(r)
}

/*
GetApplicationUsingGET getApplication

Returns application information and links to associated resources.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationGuid The application GUID.
 @return ApiGetApplicationUsingGETRequest
*/
func (a *ApplicationInformationAPIAPIService) GetApplicationUsingGET(ctx context.Context, applicationGuid string) ApiGetApplicationUsingGETRequest {
	return ApiGetApplicationUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		applicationGuid: applicationGuid,
	}
}

// Execute executes the request
//  @return Application
func (a *ApplicationInformationAPIAPIService) GetApplicationUsingGETExecute(r ApiGetApplicationUsingGETRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationInformationAPIAPIService.GetApplicationUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/applications/{applicationGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationGuid"+"}", url.PathEscape(parameterValueToString(r.applicationGuid, "applicationGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationsUsingGETRequest struct {
	ctx context.Context
	ApiService *ApplicationInformationAPIAPIService
	businessUnit *string
	customFieldNames *[]string
	customFieldValues *[]string
	legacyId *int32
	modifiedAfter *time.Time
	name *string
	page *int32
	policy *string
	policyCompliance *string
	policyComplianceCheckedAfter *time.Time
	policyGuid *string
	scanStatus *[]string
	scanType *string
	size *int32
	sortByCustomFieldName *string
	tag *string
	team *string
}

// Business unit.
func (r ApiGetApplicationsUsingGETRequest) BusinessUnit(businessUnit string) ApiGetApplicationsUsingGETRequest {
	r.businessUnit = &businessUnit
	return r
}

// Custom field names to search.
func (r ApiGetApplicationsUsingGETRequest) CustomFieldNames(customFieldNames []string) ApiGetApplicationsUsingGETRequest {
	r.customFieldNames = &customFieldNames
	return r
}

// Custom field values to search.
func (r ApiGetApplicationsUsingGETRequest) CustomFieldValues(customFieldValues []string) ApiGetApplicationsUsingGETRequest {
	r.customFieldValues = &customFieldValues
	return r
}

// The unique identifier of the Veracode Platform application.
func (r ApiGetApplicationsUsingGETRequest) LegacyId(legacyId int32) ApiGetApplicationsUsingGETRequest {
	r.legacyId = &legacyId
	return r
}

// Filter the results to return only those modified after this date. If there are multiple results for the same application, only the last modified result is returned. Format: yyyy-MM-dd
func (r ApiGetApplicationsUsingGETRequest) ModifiedAfter(modifiedAfter time.Time) ApiGetApplicationsUsingGETRequest {
	r.modifiedAfter = &modifiedAfter
	return r
}

// Application name. URL-encode any special characters.
func (r ApiGetApplicationsUsingGETRequest) Name(name string) ApiGetApplicationsUsingGETRequest {
	r.name = &name
	return r
}

// Page number. Defaults to 0.
func (r ApiGetApplicationsUsingGETRequest) Page(page int32) ApiGetApplicationsUsingGETRequest {
	r.page = &page
	return r
}

// policy
func (r ApiGetApplicationsUsingGETRequest) Policy(policy string) ApiGetApplicationsUsingGETRequest {
	r.policy = &policy
	return r
}

// The policy compliance status.
func (r ApiGetApplicationsUsingGETRequest) PolicyCompliance(policyCompliance string) ApiGetApplicationsUsingGETRequest {
	r.policyCompliance = &policyCompliance
	return r
}

// Filter the results to return only those with policy compliance checked after this date. Format: yyyy-MM-dd
func (r ApiGetApplicationsUsingGETRequest) PolicyComplianceCheckedAfter(policyComplianceCheckedAfter time.Time) ApiGetApplicationsUsingGETRequest {
	r.policyComplianceCheckedAfter = &policyComplianceCheckedAfter
	return r
}

// Policy GUID of the policy to change.
func (r ApiGetApplicationsUsingGETRequest) PolicyGuid(policyGuid string) ApiGetApplicationsUsingGETRequest {
	r.policyGuid = &policyGuid
	return r
}

// The scan status of the application.
func (r ApiGetApplicationsUsingGETRequest) ScanStatus(scanStatus []string) ApiGetApplicationsUsingGETRequest {
	r.scanStatus = &scanStatus
	return r
}

// The scan type of the application scans.
func (r ApiGetApplicationsUsingGETRequest) ScanType(scanType string) ApiGetApplicationsUsingGETRequest {
	r.scanType = &scanType
	return r
}

// Page size, up to 500. The default is 50.
func (r ApiGetApplicationsUsingGETRequest) Size(size int32) ApiGetApplicationsUsingGETRequest {
	r.size = &size
	return r
}

// Custom field name on which to sort.
func (r ApiGetApplicationsUsingGETRequest) SortByCustomFieldName(sortByCustomFieldName string) ApiGetApplicationsUsingGETRequest {
	r.sortByCustomFieldName = &sortByCustomFieldName
	return r
}

// tag
func (r ApiGetApplicationsUsingGETRequest) Tag(tag string) ApiGetApplicationsUsingGETRequest {
	r.tag = &tag
	return r
}

// Filter the results by team name.
func (r ApiGetApplicationsUsingGETRequest) Team(team string) ApiGetApplicationsUsingGETRequest {
	r.team = &team
	return r
}

func (r ApiGetApplicationsUsingGETRequest) Execute() (*PagedResourceOfApplication, *http.Response, error) {
	return r.ApiService.GetApplicationsUsingGETExecute(r)
}

/*
GetApplicationsUsingGET getApplications

Returns a list of applications. Each applications has links to sandboxes, findings, and policies. The policy is associated with an application in the application profile and in other associations via parameters such as App_Team.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApplicationsUsingGETRequest
*/
func (a *ApplicationInformationAPIAPIService) GetApplicationsUsingGET(ctx context.Context) ApiGetApplicationsUsingGETRequest {
	return ApiGetApplicationsUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PagedResourceOfApplication
func (a *ApplicationInformationAPIAPIService) GetApplicationsUsingGETExecute(r ApiGetApplicationsUsingGETRequest) (*PagedResourceOfApplication, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagedResourceOfApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationInformationAPIAPIService.GetApplicationsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.businessUnit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "business_unit", r.businessUnit, "", "")
	}
	if r.customFieldNames != nil {
		t := *r.customFieldNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "custom_field_names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "custom_field_names", t, "form", "multi")
		}
	}
	if r.customFieldValues != nil {
		t := *r.customFieldValues
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "custom_field_values", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "custom_field_values", t, "form", "multi")
		}
	}
	if r.legacyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "legacy_id", r.legacyId, "", "")
	}
	if r.modifiedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_after", r.modifiedAfter, "", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "", "")
	}
	if r.policy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policy", r.policy, "", "")
	}
	if r.policyCompliance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policy_compliance", r.policyCompliance, "", "")
	}
	if r.policyComplianceCheckedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policy_compliance_checked_after", r.policyComplianceCheckedAfter, "", "")
	}
	if r.policyGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policy_guid", r.policyGuid, "", "")
	}
	if r.scanStatus != nil {
		t := *r.scanStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scan_status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scan_status", t, "form", "multi")
		}
	}
	if r.scanType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scan_type", r.scanType, "", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "", "")
	}
	if r.sortByCustomFieldName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by_custom_field_name", r.sortByCustomFieldName, "", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "", "")
	}
	if r.team != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "team", r.team, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApplicationUsingPUTRequest struct {
	ctx context.Context
	ApiService *ApplicationInformationAPIAPIService
	applicationGuid string
	application *Application
	method *string
	policyGuid *string
}

// The Application object being updated.
func (r ApiUpdateApplicationUsingPUTRequest) Application(application Application) ApiUpdateApplicationUsingPUTRequest {
	r.application = &application
	return r
}

// This method performs a partial update of any custom policy data.
func (r ApiUpdateApplicationUsingPUTRequest) Method(method string) ApiUpdateApplicationUsingPUTRequest {
	r.method = &method
	return r
}

// Policy GUID of the policy to be changed.
func (r ApiUpdateApplicationUsingPUTRequest) PolicyGuid(policyGuid string) ApiUpdateApplicationUsingPUTRequest {
	r.policyGuid = &policyGuid
	return r
}

func (r ApiUpdateApplicationUsingPUTRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.UpdateApplicationUsingPUTExecute(r)
}

/*
UpdateApplicationUsingPUT Updates an application

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationGuid The application GUID.
 @return ApiUpdateApplicationUsingPUTRequest
*/
func (a *ApplicationInformationAPIAPIService) UpdateApplicationUsingPUT(ctx context.Context, applicationGuid string) ApiUpdateApplicationUsingPUTRequest {
	return ApiUpdateApplicationUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
		applicationGuid: applicationGuid,
	}
}

// Execute executes the request
//  @return Application
func (a *ApplicationInformationAPIAPIService) UpdateApplicationUsingPUTExecute(r ApiUpdateApplicationUsingPUTRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationInformationAPIAPIService.UpdateApplicationUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/applications/{applicationGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationGuid"+"}", url.PathEscape(parameterValueToString(r.applicationGuid, "applicationGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.application == nil {
		return localVarReturnValue, nil, reportError("application is required and must be specified")
	}

	if r.method != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "method", r.method, "", "")
	}
	if r.policyGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policy_guid", r.policyGuid, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.application
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
