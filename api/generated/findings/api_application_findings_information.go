/*
Veracode Findings API Specification

Veracode Findings API Documentation  Use one of the following base URLs depending on the region for your account: * https://api.veracode.com/ - Veracode US Region (default) * https://api.veracode.eu/ - Veracode European Region * https://api.veracode.us/ - Veracode US Federal Region

API version: 2.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package findings

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
	"time"
)

// ApplicationFindingsInformationAPIService ApplicationFindingsInformationAPI service
type ApplicationFindingsInformationAPIService service

type ApiGetFindingsUsingGETRequest struct {
	ctx             context.Context
	ApiService      *ApplicationFindingsInformationAPIService
	applicationGuid string
	context         *string
	cve             *string
	cvss            *float64
	cvssGte         *float64
	cwe             *[]int32
	findingCategory *[]int32
	includeAnnot    *bool
	includeExpDate  *bool
	mitigatedAfter  *time.Time
	new             *bool
	page            *int32
	scaDepMode      *string
	scaScanMode     *string
	scanType        *[]string
	severity        *int32
	severityGte     *int32
	size            *int32
	violatesPolicy  *bool
}

// Context type, which filters results to show only the findings of this specific context type. The findings status parameter is relative to this context parameter.
func (r ApiGetFindingsUsingGETRequest) Context(context string) ApiGetFindingsUsingGETRequest {
	r.context = &context
	return r
}

// CVE ID.
func (r ApiGetFindingsUsingGETRequest) Cve(cve string) ApiGetFindingsUsingGETRequest {
	r.cve = &cve
	return r
}

// CVSS ID (0-10), which can be double (decimal) values. This filter returns all findings with a CVSS value equal to the provided value.
func (r ApiGetFindingsUsingGETRequest) Cvss(cvss float64) ApiGetFindingsUsingGETRequest {
	r.cvss = &cvss
	return r
}

// CVSS ID (0-10), which can be double (decimal) values. This filter returns all findings with a CVSS value greater than or equal to the provided value.
func (r ApiGetFindingsUsingGETRequest) CvssGte(cvssGte float64) ApiGetFindingsUsingGETRequest {
	r.cvssGte = &cvssGte
	return r
}

// CWE ID (single or comma-delimited).
func (r ApiGetFindingsUsingGETRequest) Cwe(cwe []int32) ApiGetFindingsUsingGETRequest {
	r.cwe = &cwe
	return r
}

// Category of finding (single or comma-delimited). Not valid for the SCA scan type.
func (r ApiGetFindingsUsingGETRequest) FindingCategory(findingCategory []int32) ApiGetFindingsUsingGETRequest {
	r.findingCategory = &findingCategory
	return r
}

// Use this flag to include the annotations in the response. Not valid for the SCA scan type.
func (r ApiGetFindingsUsingGETRequest) IncludeAnnot(includeAnnot bool) ApiGetFindingsUsingGETRequest {
	r.includeAnnot = &includeAnnot
	return r
}

// Use this flag to include findings grace period expiry date in the response.
func (r ApiGetFindingsUsingGETRequest) IncludeExpDate(includeExpDate bool) ApiGetFindingsUsingGETRequest {
	r.includeExpDate = &includeExpDate
	return r
}

// Return all findings with annotations mitigated after the specified date. Does not apply to the SCA scan type. Use date format: yyyy-MM-dd
func (r ApiGetFindingsUsingGETRequest) MitigatedAfter(mitigatedAfter time.Time) ApiGetFindingsUsingGETRequest {
	r.mitigatedAfter = &mitigatedAfter
	return r
}

// Use this flag to include only new findings in the current context (policy or sandbox) in the response.
func (r ApiGetFindingsUsingGETRequest) New(new bool) ApiGetFindingsUsingGETRequest {
	r.new = &new
	return r
}

// Page number. The default is 0.
func (r ApiGetFindingsUsingGETRequest) Page(page int32) ApiGetFindingsUsingGETRequest {
	r.page = &page
	return r
}

// Return all findings with the specified SCA dependency mode. Only valid for the SCA scan type.
func (r ApiGetFindingsUsingGETRequest) ScaDepMode(scaDepMode string) ApiGetFindingsUsingGETRequest {
	r.scaDepMode = &scaDepMode
	return r
}

// Return all findings from SCA scans of the specified scan mode. Only valid for the SCA scan type.
func (r ApiGetFindingsUsingGETRequest) ScaScanMode(scaScanMode string) ApiGetFindingsUsingGETRequest {
	r.scaScanMode = &scaScanMode
	return r
}

// Type of scan in which the finding was found (single or comma-delimited).
func (r ApiGetFindingsUsingGETRequest) ScanType(scanType []string) ApiGetFindingsUsingGETRequest {
	r.scanType = &scanType
	return r
}

// This filter returns all findings with this severity value (0-5).
func (r ApiGetFindingsUsingGETRequest) Severity(severity int32) ApiGetFindingsUsingGETRequest {
	r.severity = &severity
	return r
}

// This filter returns all scan findings with a severity value greater than or equal to the value of the filter (0-5).
func (r ApiGetFindingsUsingGETRequest) SeverityGte(severityGte int32) ApiGetFindingsUsingGETRequest {
	r.severityGte = &severityGte
	return r
}

// Page size (0-500). The default is 100.
func (r ApiGetFindingsUsingGETRequest) Size(size int32) ApiGetFindingsUsingGETRequest {
	r.size = &size
	return r
}

// Use this flag to filter the results based on whether the results violate the policy associated with the application. True means the results negatively impact the policy and should be fixed. Not valid for the SCA scan type.
func (r ApiGetFindingsUsingGETRequest) ViolatesPolicy(violatesPolicy bool) ApiGetFindingsUsingGETRequest {
	r.violatesPolicy = &violatesPolicy
	return r
}

func (r ApiGetFindingsUsingGETRequest) Execute() (*PagedResourceOfFinding, *http.Response, error) {
	return r.ApiService.GetFindingsUsingGETExecute(r)
}

/*
GetFindingsUsingGET getFindings

Returns findings information from Veracode scans.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationGuid The application identifier.
	@return ApiGetFindingsUsingGETRequest
*/
func (a *ApplicationFindingsInformationAPIService) GetFindingsUsingGET(ctx context.Context, applicationGuid string) ApiGetFindingsUsingGETRequest {
	return ApiGetFindingsUsingGETRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationGuid: applicationGuid,
	}
}

// Execute executes the request
//
//	@return PagedResourceOfFinding
func (a *ApplicationFindingsInformationAPIService) GetFindingsUsingGETExecute(r ApiGetFindingsUsingGETRequest) (*PagedResourceOfFinding, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResourceOfFinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationFindingsInformationAPIService.GetFindingsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v2/applications/{application_guid}/findings"
	localVarPath = strings.Replace(localVarPath, "{"+"application_guid"+"}", url.PathEscape(parameterValueToString(r.applicationGuid, "applicationGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.cve != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cve", r.cve, "form", "")
	}
	if r.cvss != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cvss", r.cvss, "form", "")
	}
	if r.cvssGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cvss_gte", r.cvssGte, "form", "")
	}
	if r.cwe != nil {
		t := *r.cwe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cwe", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cwe", t, "form", "multi")
		}
	}
	if r.findingCategory != nil {
		t := *r.findingCategory
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "finding_category", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "finding_category", t, "form", "multi")
		}
	}
	if r.includeAnnot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_annot", r.includeAnnot, "form", "")
	}
	if r.includeExpDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_exp_date", r.includeExpDate, "form", "")
	}
	if r.mitigatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigated_after", r.mitigatedAfter, "form", "")
	}
	if r.new != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "new", r.new, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.scaDepMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sca_dep_mode", r.scaDepMode, "form", "")
	}
	if r.scaScanMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sca_scan_mode", r.scaScanMode, "form", "")
	}
	if r.scanType != nil {
		t := *r.scanType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scan_type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scan_type", t, "form", "multi")
		}
	}
	if r.severity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity", r.severity, "form", "")
	}
	if r.severityGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity_gte", r.severityGte, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.violatesPolicy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "violates_policy", r.violatesPolicy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
