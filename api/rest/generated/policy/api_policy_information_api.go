/*
Veracode Policy API Specification

Veracode Policy API Documentation Use one of the following base URLs depending on the region for your account: * https://api.veracode.com/ - Veracode Global Region (default) * https://api.veracode.eu/ - Veracode European Region * https://api.veracode.us/ - Veracode US Federal Region

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package policy

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// PolicyInformationAPIAPIService PolicyInformationAPIAPI service
type PolicyInformationAPIAPIService service

type ApiCreatePolicyUsingPOSTRequest struct {
	ctx        context.Context
	ApiService *PolicyInformationAPIAPIService
	policy     *PolicyVersion
}

// The policy object to be created.
func (r ApiCreatePolicyUsingPOSTRequest) Policy(policy PolicyVersion) ApiCreatePolicyUsingPOSTRequest {
	r.policy = &policy
	return r
}

func (r ApiCreatePolicyUsingPOSTRequest) Execute() (*PolicyVersion, *http.Response, error) {
	return r.ApiService.CreatePolicyUsingPOSTExecute(r)
}

/*
CreatePolicyUsingPOST Create a new policy.

Create and return the new policy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreatePolicyUsingPOSTRequest
*/
func (a *PolicyInformationAPIAPIService) CreatePolicyUsingPOST(ctx context.Context) ApiCreatePolicyUsingPOSTRequest {
	return ApiCreatePolicyUsingPOSTRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PolicyVersion
func (a *PolicyInformationAPIAPIService) CreatePolicyUsingPOSTExecute(r ApiCreatePolicyUsingPOSTRequest) (*PolicyVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyInformationAPIAPIService.CreatePolicyUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policy == nil {
		return localVarReturnValue, nil, reportError("policy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePolicyUsingDELETERequest struct {
	ctx                      context.Context
	ApiService               *PolicyInformationAPIAPIService
	policyGuid               string
	replaceWithDefaultPolicy *bool
	replacementGUID          *string
}

// Replace with the default policy, based on the business criticality of the application.
func (r ApiDeletePolicyUsingDELETERequest) ReplaceWithDefaultPolicy(replaceWithDefaultPolicy bool) ApiDeletePolicyUsingDELETERequest {
	r.replaceWithDefaultPolicy = &replaceWithDefaultPolicy
	return r
}

// The unique identifier of the replacement policy (GUID).
func (r ApiDeletePolicyUsingDELETERequest) ReplacementGUID(replacementGUID string) ApiDeletePolicyUsingDELETERequest {
	r.replacementGUID = &replacementGUID
	return r
}

func (r ApiDeletePolicyUsingDELETERequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeletePolicyUsingDELETEExecute(r)
}

/*
DeletePolicyUsingDELETE Delete all versions of the policy.

Delete the policy. This deletion only succeeds if the policy is not associated with any applications or policy evaluations.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyGuid The unique identifier of the policy (GUID).
	@return ApiDeletePolicyUsingDELETERequest
*/
func (a *PolicyInformationAPIAPIService) DeletePolicyUsingDELETE(ctx context.Context, policyGuid string) ApiDeletePolicyUsingDELETERequest {
	return ApiDeletePolicyUsingDELETERequest{
		ApiService: a,
		ctx:        ctx,
		policyGuid: policyGuid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *PolicyInformationAPIAPIService) DeletePolicyUsingDELETEExecute(r ApiDeletePolicyUsingDELETERequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyInformationAPIAPIService.DeletePolicyUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/policies/{policyGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyGuid"+"}", url.PathEscape(parameterValueToString(r.policyGuid, "policyGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.replaceWithDefaultPolicy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replace_with_default_policy", r.replaceWithDefaultPolicy, "", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "replace_with_default_policy", defaultValue, "", "")
		r.replaceWithDefaultPolicy = &defaultValue
	}
	if r.replacementGUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replacement_GUID", r.replacementGUID, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPoliciesUsingGETRequest struct {
	ctx            context.Context
	ApiService     *PolicyInformationAPIAPIService
	category       *string
	legacyPolicyId *int32
	name           *string
	nameExact      *bool
	page           *int32
	publicPolicy   *bool
	size           *int32
	vendorPolicy   *bool
}

// The category of the policy.
func (r ApiGetPoliciesUsingGETRequest) Category(category string) ApiGetPoliciesUsingGETRequest {
	r.category = &category
	return r
}

// Filters results based on the ID of the custom policy created in the Veracode Platform.
func (r ApiGetPoliciesUsingGETRequest) LegacyPolicyId(legacyPolicyId int32) ApiGetPoliciesUsingGETRequest {
	r.legacyPolicyId = &legacyPolicyId
	return r
}

// Filter on the policy name.
func (r ApiGetPoliciesUsingGETRequest) Name(name string) ApiGetPoliciesUsingGETRequest {
	r.name = &name
	return r
}

// Use this flag to enforce exact name-matching when filtering on the policy name.
func (r ApiGetPoliciesUsingGETRequest) NameExact(nameExact bool) ApiGetPoliciesUsingGETRequest {
	r.nameExact = &nameExact
	return r
}

// Page number. Defaults to 0.
func (r ApiGetPoliciesUsingGETRequest) Page(page int32) ApiGetPoliciesUsingGETRequest {
	r.page = &page
	return r
}

// Filters results to include or exclude a public Veracode policy.
func (r ApiGetPoliciesUsingGETRequest) PublicPolicy(publicPolicy bool) ApiGetPoliciesUsingGETRequest {
	r.publicPolicy = &publicPolicy
	return r
}

// Page size (1-500, defaults to 50).
func (r ApiGetPoliciesUsingGETRequest) Size(size int32) ApiGetPoliciesUsingGETRequest {
	r.size = &size
	return r
}

// Filters results to those with or without a vendor policy flag.
func (r ApiGetPoliciesUsingGETRequest) VendorPolicy(vendorPolicy bool) ApiGetPoliciesUsingGETRequest {
	r.vendorPolicy = &vendorPolicy
	return r
}

func (r ApiGetPoliciesUsingGETRequest) Execute() (*PagedResourceOfPolicyVersion, *http.Response, error) {
	return r.ApiService.GetPoliciesUsingGETExecute(r)
}

/*
GetPoliciesUsingGET getPolicies

Returns a list of policies. The individual policy has links to policy evaluations performed against this policy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPoliciesUsingGETRequest
*/
func (a *PolicyInformationAPIAPIService) GetPoliciesUsingGET(ctx context.Context) ApiGetPoliciesUsingGETRequest {
	return ApiGetPoliciesUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PagedResourceOfPolicyVersion
func (a *PolicyInformationAPIAPIService) GetPoliciesUsingGETExecute(r ApiGetPoliciesUsingGETRequest) (*PagedResourceOfPolicyVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResourceOfPolicyVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyInformationAPIAPIService.GetPoliciesUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "", "")
	}
	if r.legacyPolicyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "legacy_policy_id", r.legacyPolicyId, "", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "", "")
	}
	if r.nameExact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name_exact", r.nameExact, "", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "", "")
	}
	if r.publicPolicy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "public_policy", r.publicPolicy, "", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "public_policy", defaultValue, "", "")
		r.publicPolicy = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "", "")
	}
	if r.vendorPolicy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendor_policy", r.vendorPolicy, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyUsingGETRequest struct {
	ctx        context.Context
	ApiService *PolicyInformationAPIAPIService
	policyGuid string
}

func (r ApiGetPolicyUsingGETRequest) Execute() (*PolicyVersion, *http.Response, error) {
	return r.ApiService.GetPolicyUsingGETExecute(r)
}

/*
GetPolicyUsingGET getPolicy

Returns the latest version of the policy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyGuid The unique identifier of the policy (GUID).
	@return ApiGetPolicyUsingGETRequest
*/
func (a *PolicyInformationAPIAPIService) GetPolicyUsingGET(ctx context.Context, policyGuid string) ApiGetPolicyUsingGETRequest {
	return ApiGetPolicyUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
		policyGuid: policyGuid,
	}
}

// Execute executes the request
//
//	@return PolicyVersion
func (a *PolicyInformationAPIAPIService) GetPolicyUsingGETExecute(r ApiGetPolicyUsingGETRequest) (*PolicyVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyInformationAPIAPIService.GetPolicyUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/policies/{policyGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyGuid"+"}", url.PathEscape(parameterValueToString(r.policyGuid, "policyGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyVersionUsingGETRequest struct {
	ctx        context.Context
	ApiService *PolicyInformationAPIAPIService
	policyGuid string
	version    int32
}

func (r ApiGetPolicyVersionUsingGETRequest) Execute() (*PolicyVersion, *http.Response, error) {
	return r.ApiService.GetPolicyVersionUsingGETExecute(r)
}

/*
GetPolicyVersionUsingGET getPolicyVersion

Returns the requested policy version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyGuid The unique identifier of the policy (GUID).
	@param version The specific version of this policy. The default is the last version provided.
	@return ApiGetPolicyVersionUsingGETRequest
*/
func (a *PolicyInformationAPIAPIService) GetPolicyVersionUsingGET(ctx context.Context, policyGuid string, version int32) ApiGetPolicyVersionUsingGETRequest {
	return ApiGetPolicyVersionUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
		policyGuid: policyGuid,
		version:    version,
	}
}

// Execute executes the request
//
//	@return PolicyVersion
func (a *PolicyInformationAPIAPIService) GetPolicyVersionUsingGETExecute(r ApiGetPolicyVersionUsingGETRequest) (*PolicyVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyInformationAPIAPIService.GetPolicyVersionUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/policies/{policyGuid}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyGuid"+"}", url.PathEscape(parameterValueToString(r.policyGuid, "policyGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyVersionsUsingGETRequest struct {
	ctx        context.Context
	ApiService *PolicyInformationAPIAPIService
	policyGuid string
	page       *int32
	size       *int32
}

// Page number. Defaults to 0.
func (r ApiGetPolicyVersionsUsingGETRequest) Page(page int32) ApiGetPolicyVersionsUsingGETRequest {
	r.page = &page
	return r
}

// Page size (1-500). Defaults to 50.
func (r ApiGetPolicyVersionsUsingGETRequest) Size(size int32) ApiGetPolicyVersionsUsingGETRequest {
	r.size = &size
	return r
}

func (r ApiGetPolicyVersionsUsingGETRequest) Execute() (*PagedResourceOfPolicyVersion, *http.Response, error) {
	return r.ApiService.GetPolicyVersionsUsingGETExecute(r)
}

/*
GetPolicyVersionsUsingGET getPolicyVersions

Returns a list of all versions of the policy. Past versions of the policy that are not currently linked to an application or evaluation are deleted and do not appear in this list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyGuid The unique identifier of the policy (GUID).
	@return ApiGetPolicyVersionsUsingGETRequest
*/
func (a *PolicyInformationAPIAPIService) GetPolicyVersionsUsingGET(ctx context.Context, policyGuid string) ApiGetPolicyVersionsUsingGETRequest {
	return ApiGetPolicyVersionsUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
		policyGuid: policyGuid,
	}
}

// Execute executes the request
//
//	@return PagedResourceOfPolicyVersion
func (a *PolicyInformationAPIAPIService) GetPolicyVersionsUsingGETExecute(r ApiGetPolicyVersionsUsingGETRequest) (*PagedResourceOfPolicyVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResourceOfPolicyVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyInformationAPIAPIService.GetPolicyVersionsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/policies/{policyGuid}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"policyGuid"+"}", url.PathEscape(parameterValueToString(r.policyGuid, "policyGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePolicyUsingPUTRequest struct {
	ctx        context.Context
	ApiService *PolicyInformationAPIAPIService
	policyGuid string
	policy     *PolicyVersion
}

// The new policy version to be created.
func (r ApiUpdatePolicyUsingPUTRequest) Policy(policy PolicyVersion) ApiUpdatePolicyUsingPUTRequest {
	r.policy = &policy
	return r
}

func (r ApiUpdatePolicyUsingPUTRequest) Execute() (*PolicyVersion, *http.Response, error) {
	return r.ApiService.UpdatePolicyUsingPUTExecute(r)
}

/*
UpdatePolicyUsingPUT Update the policy.

Creates a new version of the policy that is the default when making a GET call to this endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyGuid The unique identifier of the policy (GUID).
	@return ApiUpdatePolicyUsingPUTRequest
*/
func (a *PolicyInformationAPIAPIService) UpdatePolicyUsingPUT(ctx context.Context, policyGuid string) ApiUpdatePolicyUsingPUTRequest {
	return ApiUpdatePolicyUsingPUTRequest{
		ApiService: a,
		ctx:        ctx,
		policyGuid: policyGuid,
	}
}

// Execute executes the request
//
//	@return PolicyVersion
func (a *PolicyInformationAPIAPIService) UpdatePolicyUsingPUTExecute(r ApiUpdatePolicyUsingPUTRequest) (*PolicyVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyInformationAPIAPIService.UpdatePolicyUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appsec/v1/policies/{policyGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyGuid"+"}", url.PathEscape(parameterValueToString(r.policyGuid, "policyGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policy == nil {
		return localVarReturnValue, nil, reportError("policy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
